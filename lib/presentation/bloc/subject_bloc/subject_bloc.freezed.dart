// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'subject_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SubjectEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadSubjects,
    required TResult Function(List<SubjectModel> subjects) toLoaded,
    required TResult Function(List<SubjectModel> subjects, String name)
        createSubject,
    required TResult Function(List<SubjectModel> subjects, int id, String name)
        updateSubject,
    required TResult Function(List<SubjectModel> subjects, int id)
        deleteSubject,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadSubjects,
    TResult? Function(List<SubjectModel> subjects)? toLoaded,
    TResult? Function(List<SubjectModel> subjects, String name)? createSubject,
    TResult? Function(List<SubjectModel> subjects, int id, String name)?
        updateSubject,
    TResult? Function(List<SubjectModel> subjects, int id)? deleteSubject,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadSubjects,
    TResult Function(List<SubjectModel> subjects)? toLoaded,
    TResult Function(List<SubjectModel> subjects, String name)? createSubject,
    TResult Function(List<SubjectModel> subjects, int id, String name)?
        updateSubject,
    TResult Function(List<SubjectModel> subjects, int id)? deleteSubject,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubjectEventLoadSubjects value) loadSubjects,
    required TResult Function(SubjectEventToLoaded value) toLoaded,
    required TResult Function(SubjectEventCreateSubject value) createSubject,
    required TResult Function(SubjectEventUpdateSubject value) updateSubject,
    required TResult Function(SubjectEventDeleteSubject value) deleteSubject,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubjectEventLoadSubjects value)? loadSubjects,
    TResult? Function(SubjectEventToLoaded value)? toLoaded,
    TResult? Function(SubjectEventCreateSubject value)? createSubject,
    TResult? Function(SubjectEventUpdateSubject value)? updateSubject,
    TResult? Function(SubjectEventDeleteSubject value)? deleteSubject,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubjectEventLoadSubjects value)? loadSubjects,
    TResult Function(SubjectEventToLoaded value)? toLoaded,
    TResult Function(SubjectEventCreateSubject value)? createSubject,
    TResult Function(SubjectEventUpdateSubject value)? updateSubject,
    TResult Function(SubjectEventDeleteSubject value)? deleteSubject,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubjectEventCopyWith<$Res> {
  factory $SubjectEventCopyWith(
          SubjectEvent value, $Res Function(SubjectEvent) then) =
      _$SubjectEventCopyWithImpl<$Res, SubjectEvent>;
}

/// @nodoc
class _$SubjectEventCopyWithImpl<$Res, $Val extends SubjectEvent>
    implements $SubjectEventCopyWith<$Res> {
  _$SubjectEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SubjectEventLoadSubjectsImplCopyWith<$Res> {
  factory _$$SubjectEventLoadSubjectsImplCopyWith(
          _$SubjectEventLoadSubjectsImpl value,
          $Res Function(_$SubjectEventLoadSubjectsImpl) then) =
      __$$SubjectEventLoadSubjectsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SubjectEventLoadSubjectsImplCopyWithImpl<$Res>
    extends _$SubjectEventCopyWithImpl<$Res, _$SubjectEventLoadSubjectsImpl>
    implements _$$SubjectEventLoadSubjectsImplCopyWith<$Res> {
  __$$SubjectEventLoadSubjectsImplCopyWithImpl(
      _$SubjectEventLoadSubjectsImpl _value,
      $Res Function(_$SubjectEventLoadSubjectsImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SubjectEventLoadSubjectsImpl implements SubjectEventLoadSubjects {
  const _$SubjectEventLoadSubjectsImpl();

  @override
  String toString() {
    return 'SubjectEvent.loadSubjects()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubjectEventLoadSubjectsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadSubjects,
    required TResult Function(List<SubjectModel> subjects) toLoaded,
    required TResult Function(List<SubjectModel> subjects, String name)
        createSubject,
    required TResult Function(List<SubjectModel> subjects, int id, String name)
        updateSubject,
    required TResult Function(List<SubjectModel> subjects, int id)
        deleteSubject,
  }) {
    return loadSubjects();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadSubjects,
    TResult? Function(List<SubjectModel> subjects)? toLoaded,
    TResult? Function(List<SubjectModel> subjects, String name)? createSubject,
    TResult? Function(List<SubjectModel> subjects, int id, String name)?
        updateSubject,
    TResult? Function(List<SubjectModel> subjects, int id)? deleteSubject,
  }) {
    return loadSubjects?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadSubjects,
    TResult Function(List<SubjectModel> subjects)? toLoaded,
    TResult Function(List<SubjectModel> subjects, String name)? createSubject,
    TResult Function(List<SubjectModel> subjects, int id, String name)?
        updateSubject,
    TResult Function(List<SubjectModel> subjects, int id)? deleteSubject,
    required TResult orElse(),
  }) {
    if (loadSubjects != null) {
      return loadSubjects();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubjectEventLoadSubjects value) loadSubjects,
    required TResult Function(SubjectEventToLoaded value) toLoaded,
    required TResult Function(SubjectEventCreateSubject value) createSubject,
    required TResult Function(SubjectEventUpdateSubject value) updateSubject,
    required TResult Function(SubjectEventDeleteSubject value) deleteSubject,
  }) {
    return loadSubjects(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubjectEventLoadSubjects value)? loadSubjects,
    TResult? Function(SubjectEventToLoaded value)? toLoaded,
    TResult? Function(SubjectEventCreateSubject value)? createSubject,
    TResult? Function(SubjectEventUpdateSubject value)? updateSubject,
    TResult? Function(SubjectEventDeleteSubject value)? deleteSubject,
  }) {
    return loadSubjects?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubjectEventLoadSubjects value)? loadSubjects,
    TResult Function(SubjectEventToLoaded value)? toLoaded,
    TResult Function(SubjectEventCreateSubject value)? createSubject,
    TResult Function(SubjectEventUpdateSubject value)? updateSubject,
    TResult Function(SubjectEventDeleteSubject value)? deleteSubject,
    required TResult orElse(),
  }) {
    if (loadSubjects != null) {
      return loadSubjects(this);
    }
    return orElse();
  }
}

abstract class SubjectEventLoadSubjects implements SubjectEvent {
  const factory SubjectEventLoadSubjects() = _$SubjectEventLoadSubjectsImpl;
}

/// @nodoc
abstract class _$$SubjectEventToLoadedImplCopyWith<$Res> {
  factory _$$SubjectEventToLoadedImplCopyWith(_$SubjectEventToLoadedImpl value,
          $Res Function(_$SubjectEventToLoadedImpl) then) =
      __$$SubjectEventToLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<SubjectModel> subjects});
}

/// @nodoc
class __$$SubjectEventToLoadedImplCopyWithImpl<$Res>
    extends _$SubjectEventCopyWithImpl<$Res, _$SubjectEventToLoadedImpl>
    implements _$$SubjectEventToLoadedImplCopyWith<$Res> {
  __$$SubjectEventToLoadedImplCopyWithImpl(_$SubjectEventToLoadedImpl _value,
      $Res Function(_$SubjectEventToLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? subjects = null,
  }) {
    return _then(_$SubjectEventToLoadedImpl(
      null == subjects
          ? _value._subjects
          : subjects // ignore: cast_nullable_to_non_nullable
              as List<SubjectModel>,
    ));
  }
}

/// @nodoc

class _$SubjectEventToLoadedImpl implements SubjectEventToLoaded {
  const _$SubjectEventToLoadedImpl(final List<SubjectModel> subjects)
      : _subjects = subjects;

  final List<SubjectModel> _subjects;
  @override
  List<SubjectModel> get subjects {
    if (_subjects is EqualUnmodifiableListView) return _subjects;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_subjects);
  }

  @override
  String toString() {
    return 'SubjectEvent.toLoaded(subjects: $subjects)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubjectEventToLoadedImpl &&
            const DeepCollectionEquality().equals(other._subjects, _subjects));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_subjects));

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubjectEventToLoadedImplCopyWith<_$SubjectEventToLoadedImpl>
      get copyWith =>
          __$$SubjectEventToLoadedImplCopyWithImpl<_$SubjectEventToLoadedImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadSubjects,
    required TResult Function(List<SubjectModel> subjects) toLoaded,
    required TResult Function(List<SubjectModel> subjects, String name)
        createSubject,
    required TResult Function(List<SubjectModel> subjects, int id, String name)
        updateSubject,
    required TResult Function(List<SubjectModel> subjects, int id)
        deleteSubject,
  }) {
    return toLoaded(subjects);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadSubjects,
    TResult? Function(List<SubjectModel> subjects)? toLoaded,
    TResult? Function(List<SubjectModel> subjects, String name)? createSubject,
    TResult? Function(List<SubjectModel> subjects, int id, String name)?
        updateSubject,
    TResult? Function(List<SubjectModel> subjects, int id)? deleteSubject,
  }) {
    return toLoaded?.call(subjects);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadSubjects,
    TResult Function(List<SubjectModel> subjects)? toLoaded,
    TResult Function(List<SubjectModel> subjects, String name)? createSubject,
    TResult Function(List<SubjectModel> subjects, int id, String name)?
        updateSubject,
    TResult Function(List<SubjectModel> subjects, int id)? deleteSubject,
    required TResult orElse(),
  }) {
    if (toLoaded != null) {
      return toLoaded(subjects);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubjectEventLoadSubjects value) loadSubjects,
    required TResult Function(SubjectEventToLoaded value) toLoaded,
    required TResult Function(SubjectEventCreateSubject value) createSubject,
    required TResult Function(SubjectEventUpdateSubject value) updateSubject,
    required TResult Function(SubjectEventDeleteSubject value) deleteSubject,
  }) {
    return toLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubjectEventLoadSubjects value)? loadSubjects,
    TResult? Function(SubjectEventToLoaded value)? toLoaded,
    TResult? Function(SubjectEventCreateSubject value)? createSubject,
    TResult? Function(SubjectEventUpdateSubject value)? updateSubject,
    TResult? Function(SubjectEventDeleteSubject value)? deleteSubject,
  }) {
    return toLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubjectEventLoadSubjects value)? loadSubjects,
    TResult Function(SubjectEventToLoaded value)? toLoaded,
    TResult Function(SubjectEventCreateSubject value)? createSubject,
    TResult Function(SubjectEventUpdateSubject value)? updateSubject,
    TResult Function(SubjectEventDeleteSubject value)? deleteSubject,
    required TResult orElse(),
  }) {
    if (toLoaded != null) {
      return toLoaded(this);
    }
    return orElse();
  }
}

abstract class SubjectEventToLoaded implements SubjectEvent {
  const factory SubjectEventToLoaded(final List<SubjectModel> subjects) =
      _$SubjectEventToLoadedImpl;

  List<SubjectModel> get subjects;

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubjectEventToLoadedImplCopyWith<_$SubjectEventToLoadedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SubjectEventCreateSubjectImplCopyWith<$Res> {
  factory _$$SubjectEventCreateSubjectImplCopyWith(
          _$SubjectEventCreateSubjectImpl value,
          $Res Function(_$SubjectEventCreateSubjectImpl) then) =
      __$$SubjectEventCreateSubjectImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<SubjectModel> subjects, String name});
}

/// @nodoc
class __$$SubjectEventCreateSubjectImplCopyWithImpl<$Res>
    extends _$SubjectEventCopyWithImpl<$Res, _$SubjectEventCreateSubjectImpl>
    implements _$$SubjectEventCreateSubjectImplCopyWith<$Res> {
  __$$SubjectEventCreateSubjectImplCopyWithImpl(
      _$SubjectEventCreateSubjectImpl _value,
      $Res Function(_$SubjectEventCreateSubjectImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? subjects = null,
    Object? name = null,
  }) {
    return _then(_$SubjectEventCreateSubjectImpl(
      null == subjects
          ? _value._subjects
          : subjects // ignore: cast_nullable_to_non_nullable
              as List<SubjectModel>,
      null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SubjectEventCreateSubjectImpl implements SubjectEventCreateSubject {
  const _$SubjectEventCreateSubjectImpl(
      final List<SubjectModel> subjects, this.name)
      : _subjects = subjects;

  final List<SubjectModel> _subjects;
  @override
  List<SubjectModel> get subjects {
    if (_subjects is EqualUnmodifiableListView) return _subjects;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_subjects);
  }

  @override
  final String name;

  @override
  String toString() {
    return 'SubjectEvent.createSubject(subjects: $subjects, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubjectEventCreateSubjectImpl &&
            const DeepCollectionEquality().equals(other._subjects, _subjects) &&
            (identical(other.name, name) || other.name == name));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_subjects), name);

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubjectEventCreateSubjectImplCopyWith<_$SubjectEventCreateSubjectImpl>
      get copyWith => __$$SubjectEventCreateSubjectImplCopyWithImpl<
          _$SubjectEventCreateSubjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadSubjects,
    required TResult Function(List<SubjectModel> subjects) toLoaded,
    required TResult Function(List<SubjectModel> subjects, String name)
        createSubject,
    required TResult Function(List<SubjectModel> subjects, int id, String name)
        updateSubject,
    required TResult Function(List<SubjectModel> subjects, int id)
        deleteSubject,
  }) {
    return createSubject(subjects, name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadSubjects,
    TResult? Function(List<SubjectModel> subjects)? toLoaded,
    TResult? Function(List<SubjectModel> subjects, String name)? createSubject,
    TResult? Function(List<SubjectModel> subjects, int id, String name)?
        updateSubject,
    TResult? Function(List<SubjectModel> subjects, int id)? deleteSubject,
  }) {
    return createSubject?.call(subjects, name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadSubjects,
    TResult Function(List<SubjectModel> subjects)? toLoaded,
    TResult Function(List<SubjectModel> subjects, String name)? createSubject,
    TResult Function(List<SubjectModel> subjects, int id, String name)?
        updateSubject,
    TResult Function(List<SubjectModel> subjects, int id)? deleteSubject,
    required TResult orElse(),
  }) {
    if (createSubject != null) {
      return createSubject(subjects, name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubjectEventLoadSubjects value) loadSubjects,
    required TResult Function(SubjectEventToLoaded value) toLoaded,
    required TResult Function(SubjectEventCreateSubject value) createSubject,
    required TResult Function(SubjectEventUpdateSubject value) updateSubject,
    required TResult Function(SubjectEventDeleteSubject value) deleteSubject,
  }) {
    return createSubject(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubjectEventLoadSubjects value)? loadSubjects,
    TResult? Function(SubjectEventToLoaded value)? toLoaded,
    TResult? Function(SubjectEventCreateSubject value)? createSubject,
    TResult? Function(SubjectEventUpdateSubject value)? updateSubject,
    TResult? Function(SubjectEventDeleteSubject value)? deleteSubject,
  }) {
    return createSubject?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubjectEventLoadSubjects value)? loadSubjects,
    TResult Function(SubjectEventToLoaded value)? toLoaded,
    TResult Function(SubjectEventCreateSubject value)? createSubject,
    TResult Function(SubjectEventUpdateSubject value)? updateSubject,
    TResult Function(SubjectEventDeleteSubject value)? deleteSubject,
    required TResult orElse(),
  }) {
    if (createSubject != null) {
      return createSubject(this);
    }
    return orElse();
  }
}

abstract class SubjectEventCreateSubject implements SubjectEvent {
  const factory SubjectEventCreateSubject(
          final List<SubjectModel> subjects, final String name) =
      _$SubjectEventCreateSubjectImpl;

  List<SubjectModel> get subjects;
  String get name;

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubjectEventCreateSubjectImplCopyWith<_$SubjectEventCreateSubjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SubjectEventUpdateSubjectImplCopyWith<$Res> {
  factory _$$SubjectEventUpdateSubjectImplCopyWith(
          _$SubjectEventUpdateSubjectImpl value,
          $Res Function(_$SubjectEventUpdateSubjectImpl) then) =
      __$$SubjectEventUpdateSubjectImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<SubjectModel> subjects, int id, String name});
}

/// @nodoc
class __$$SubjectEventUpdateSubjectImplCopyWithImpl<$Res>
    extends _$SubjectEventCopyWithImpl<$Res, _$SubjectEventUpdateSubjectImpl>
    implements _$$SubjectEventUpdateSubjectImplCopyWith<$Res> {
  __$$SubjectEventUpdateSubjectImplCopyWithImpl(
      _$SubjectEventUpdateSubjectImpl _value,
      $Res Function(_$SubjectEventUpdateSubjectImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? subjects = null,
    Object? id = null,
    Object? name = null,
  }) {
    return _then(_$SubjectEventUpdateSubjectImpl(
      null == subjects
          ? _value._subjects
          : subjects // ignore: cast_nullable_to_non_nullable
              as List<SubjectModel>,
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SubjectEventUpdateSubjectImpl implements SubjectEventUpdateSubject {
  const _$SubjectEventUpdateSubjectImpl(
      final List<SubjectModel> subjects, this.id, this.name)
      : _subjects = subjects;

  final List<SubjectModel> _subjects;
  @override
  List<SubjectModel> get subjects {
    if (_subjects is EqualUnmodifiableListView) return _subjects;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_subjects);
  }

  @override
  final int id;
  @override
  final String name;

  @override
  String toString() {
    return 'SubjectEvent.updateSubject(subjects: $subjects, id: $id, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubjectEventUpdateSubjectImpl &&
            const DeepCollectionEquality().equals(other._subjects, _subjects) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_subjects), id, name);

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubjectEventUpdateSubjectImplCopyWith<_$SubjectEventUpdateSubjectImpl>
      get copyWith => __$$SubjectEventUpdateSubjectImplCopyWithImpl<
          _$SubjectEventUpdateSubjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadSubjects,
    required TResult Function(List<SubjectModel> subjects) toLoaded,
    required TResult Function(List<SubjectModel> subjects, String name)
        createSubject,
    required TResult Function(List<SubjectModel> subjects, int id, String name)
        updateSubject,
    required TResult Function(List<SubjectModel> subjects, int id)
        deleteSubject,
  }) {
    return updateSubject(subjects, id, name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadSubjects,
    TResult? Function(List<SubjectModel> subjects)? toLoaded,
    TResult? Function(List<SubjectModel> subjects, String name)? createSubject,
    TResult? Function(List<SubjectModel> subjects, int id, String name)?
        updateSubject,
    TResult? Function(List<SubjectModel> subjects, int id)? deleteSubject,
  }) {
    return updateSubject?.call(subjects, id, name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadSubjects,
    TResult Function(List<SubjectModel> subjects)? toLoaded,
    TResult Function(List<SubjectModel> subjects, String name)? createSubject,
    TResult Function(List<SubjectModel> subjects, int id, String name)?
        updateSubject,
    TResult Function(List<SubjectModel> subjects, int id)? deleteSubject,
    required TResult orElse(),
  }) {
    if (updateSubject != null) {
      return updateSubject(subjects, id, name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubjectEventLoadSubjects value) loadSubjects,
    required TResult Function(SubjectEventToLoaded value) toLoaded,
    required TResult Function(SubjectEventCreateSubject value) createSubject,
    required TResult Function(SubjectEventUpdateSubject value) updateSubject,
    required TResult Function(SubjectEventDeleteSubject value) deleteSubject,
  }) {
    return updateSubject(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubjectEventLoadSubjects value)? loadSubjects,
    TResult? Function(SubjectEventToLoaded value)? toLoaded,
    TResult? Function(SubjectEventCreateSubject value)? createSubject,
    TResult? Function(SubjectEventUpdateSubject value)? updateSubject,
    TResult? Function(SubjectEventDeleteSubject value)? deleteSubject,
  }) {
    return updateSubject?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubjectEventLoadSubjects value)? loadSubjects,
    TResult Function(SubjectEventToLoaded value)? toLoaded,
    TResult Function(SubjectEventCreateSubject value)? createSubject,
    TResult Function(SubjectEventUpdateSubject value)? updateSubject,
    TResult Function(SubjectEventDeleteSubject value)? deleteSubject,
    required TResult orElse(),
  }) {
    if (updateSubject != null) {
      return updateSubject(this);
    }
    return orElse();
  }
}

abstract class SubjectEventUpdateSubject implements SubjectEvent {
  const factory SubjectEventUpdateSubject(
          final List<SubjectModel> subjects, final int id, final String name) =
      _$SubjectEventUpdateSubjectImpl;

  List<SubjectModel> get subjects;
  int get id;
  String get name;

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubjectEventUpdateSubjectImplCopyWith<_$SubjectEventUpdateSubjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SubjectEventDeleteSubjectImplCopyWith<$Res> {
  factory _$$SubjectEventDeleteSubjectImplCopyWith(
          _$SubjectEventDeleteSubjectImpl value,
          $Res Function(_$SubjectEventDeleteSubjectImpl) then) =
      __$$SubjectEventDeleteSubjectImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<SubjectModel> subjects, int id});
}

/// @nodoc
class __$$SubjectEventDeleteSubjectImplCopyWithImpl<$Res>
    extends _$SubjectEventCopyWithImpl<$Res, _$SubjectEventDeleteSubjectImpl>
    implements _$$SubjectEventDeleteSubjectImplCopyWith<$Res> {
  __$$SubjectEventDeleteSubjectImplCopyWithImpl(
      _$SubjectEventDeleteSubjectImpl _value,
      $Res Function(_$SubjectEventDeleteSubjectImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? subjects = null,
    Object? id = null,
  }) {
    return _then(_$SubjectEventDeleteSubjectImpl(
      null == subjects
          ? _value._subjects
          : subjects // ignore: cast_nullable_to_non_nullable
              as List<SubjectModel>,
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SubjectEventDeleteSubjectImpl implements SubjectEventDeleteSubject {
  const _$SubjectEventDeleteSubjectImpl(
      final List<SubjectModel> subjects, this.id)
      : _subjects = subjects;

  final List<SubjectModel> _subjects;
  @override
  List<SubjectModel> get subjects {
    if (_subjects is EqualUnmodifiableListView) return _subjects;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_subjects);
  }

  @override
  final int id;

  @override
  String toString() {
    return 'SubjectEvent.deleteSubject(subjects: $subjects, id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubjectEventDeleteSubjectImpl &&
            const DeepCollectionEquality().equals(other._subjects, _subjects) &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_subjects), id);

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubjectEventDeleteSubjectImplCopyWith<_$SubjectEventDeleteSubjectImpl>
      get copyWith => __$$SubjectEventDeleteSubjectImplCopyWithImpl<
          _$SubjectEventDeleteSubjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadSubjects,
    required TResult Function(List<SubjectModel> subjects) toLoaded,
    required TResult Function(List<SubjectModel> subjects, String name)
        createSubject,
    required TResult Function(List<SubjectModel> subjects, int id, String name)
        updateSubject,
    required TResult Function(List<SubjectModel> subjects, int id)
        deleteSubject,
  }) {
    return deleteSubject(subjects, id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadSubjects,
    TResult? Function(List<SubjectModel> subjects)? toLoaded,
    TResult? Function(List<SubjectModel> subjects, String name)? createSubject,
    TResult? Function(List<SubjectModel> subjects, int id, String name)?
        updateSubject,
    TResult? Function(List<SubjectModel> subjects, int id)? deleteSubject,
  }) {
    return deleteSubject?.call(subjects, id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadSubjects,
    TResult Function(List<SubjectModel> subjects)? toLoaded,
    TResult Function(List<SubjectModel> subjects, String name)? createSubject,
    TResult Function(List<SubjectModel> subjects, int id, String name)?
        updateSubject,
    TResult Function(List<SubjectModel> subjects, int id)? deleteSubject,
    required TResult orElse(),
  }) {
    if (deleteSubject != null) {
      return deleteSubject(subjects, id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubjectEventLoadSubjects value) loadSubjects,
    required TResult Function(SubjectEventToLoaded value) toLoaded,
    required TResult Function(SubjectEventCreateSubject value) createSubject,
    required TResult Function(SubjectEventUpdateSubject value) updateSubject,
    required TResult Function(SubjectEventDeleteSubject value) deleteSubject,
  }) {
    return deleteSubject(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubjectEventLoadSubjects value)? loadSubjects,
    TResult? Function(SubjectEventToLoaded value)? toLoaded,
    TResult? Function(SubjectEventCreateSubject value)? createSubject,
    TResult? Function(SubjectEventUpdateSubject value)? updateSubject,
    TResult? Function(SubjectEventDeleteSubject value)? deleteSubject,
  }) {
    return deleteSubject?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubjectEventLoadSubjects value)? loadSubjects,
    TResult Function(SubjectEventToLoaded value)? toLoaded,
    TResult Function(SubjectEventCreateSubject value)? createSubject,
    TResult Function(SubjectEventUpdateSubject value)? updateSubject,
    TResult Function(SubjectEventDeleteSubject value)? deleteSubject,
    required TResult orElse(),
  }) {
    if (deleteSubject != null) {
      return deleteSubject(this);
    }
    return orElse();
  }
}

abstract class SubjectEventDeleteSubject implements SubjectEvent {
  const factory SubjectEventDeleteSubject(
          final List<SubjectModel> subjects, final int id) =
      _$SubjectEventDeleteSubjectImpl;

  List<SubjectModel> get subjects;
  int get id;

  /// Create a copy of SubjectEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubjectEventDeleteSubjectImplCopyWith<_$SubjectEventDeleteSubjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SubjectState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<SubjectModel> subjects) loaded,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function() endedSession,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<SubjectModel> subjects)? loaded,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function()? endedSession,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<SubjectModel> subjects)? loaded,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function()? endedSession,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubjectStateLoaded value) loaded,
    required TResult Function(SubjectStateLoading value) loading,
    required TResult Function(SubjectStateError value) error,
    required TResult Function(SubjectStateEndedSession value) endedSession,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubjectStateLoaded value)? loaded,
    TResult? Function(SubjectStateLoading value)? loading,
    TResult? Function(SubjectStateError value)? error,
    TResult? Function(SubjectStateEndedSession value)? endedSession,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubjectStateLoaded value)? loaded,
    TResult Function(SubjectStateLoading value)? loading,
    TResult Function(SubjectStateError value)? error,
    TResult Function(SubjectStateEndedSession value)? endedSession,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubjectStateCopyWith<$Res> {
  factory $SubjectStateCopyWith(
          SubjectState value, $Res Function(SubjectState) then) =
      _$SubjectStateCopyWithImpl<$Res, SubjectState>;
}

/// @nodoc
class _$SubjectStateCopyWithImpl<$Res, $Val extends SubjectState>
    implements $SubjectStateCopyWith<$Res> {
  _$SubjectStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubjectState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SubjectStateLoadedImplCopyWith<$Res> {
  factory _$$SubjectStateLoadedImplCopyWith(_$SubjectStateLoadedImpl value,
          $Res Function(_$SubjectStateLoadedImpl) then) =
      __$$SubjectStateLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<SubjectModel> subjects});
}

/// @nodoc
class __$$SubjectStateLoadedImplCopyWithImpl<$Res>
    extends _$SubjectStateCopyWithImpl<$Res, _$SubjectStateLoadedImpl>
    implements _$$SubjectStateLoadedImplCopyWith<$Res> {
  __$$SubjectStateLoadedImplCopyWithImpl(_$SubjectStateLoadedImpl _value,
      $Res Function(_$SubjectStateLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubjectState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? subjects = null,
  }) {
    return _then(_$SubjectStateLoadedImpl(
      subjects: null == subjects
          ? _value._subjects
          : subjects // ignore: cast_nullable_to_non_nullable
              as List<SubjectModel>,
    ));
  }
}

/// @nodoc

class _$SubjectStateLoadedImpl implements SubjectStateLoaded {
  const _$SubjectStateLoadedImpl({required final List<SubjectModel> subjects})
      : _subjects = subjects;

  final List<SubjectModel> _subjects;
  @override
  List<SubjectModel> get subjects {
    if (_subjects is EqualUnmodifiableListView) return _subjects;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_subjects);
  }

  @override
  String toString() {
    return 'SubjectState.loaded(subjects: $subjects)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubjectStateLoadedImpl &&
            const DeepCollectionEquality().equals(other._subjects, _subjects));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_subjects));

  /// Create a copy of SubjectState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubjectStateLoadedImplCopyWith<_$SubjectStateLoadedImpl> get copyWith =>
      __$$SubjectStateLoadedImplCopyWithImpl<_$SubjectStateLoadedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<SubjectModel> subjects) loaded,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function() endedSession,
  }) {
    return loaded(subjects);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<SubjectModel> subjects)? loaded,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function()? endedSession,
  }) {
    return loaded?.call(subjects);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<SubjectModel> subjects)? loaded,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function()? endedSession,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(subjects);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubjectStateLoaded value) loaded,
    required TResult Function(SubjectStateLoading value) loading,
    required TResult Function(SubjectStateError value) error,
    required TResult Function(SubjectStateEndedSession value) endedSession,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubjectStateLoaded value)? loaded,
    TResult? Function(SubjectStateLoading value)? loading,
    TResult? Function(SubjectStateError value)? error,
    TResult? Function(SubjectStateEndedSession value)? endedSession,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubjectStateLoaded value)? loaded,
    TResult Function(SubjectStateLoading value)? loading,
    TResult Function(SubjectStateError value)? error,
    TResult Function(SubjectStateEndedSession value)? endedSession,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class SubjectStateLoaded implements SubjectState {
  const factory SubjectStateLoaded(
      {required final List<SubjectModel> subjects}) = _$SubjectStateLoadedImpl;

  List<SubjectModel> get subjects;

  /// Create a copy of SubjectState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubjectStateLoadedImplCopyWith<_$SubjectStateLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SubjectStateLoadingImplCopyWith<$Res> {
  factory _$$SubjectStateLoadingImplCopyWith(_$SubjectStateLoadingImpl value,
          $Res Function(_$SubjectStateLoadingImpl) then) =
      __$$SubjectStateLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SubjectStateLoadingImplCopyWithImpl<$Res>
    extends _$SubjectStateCopyWithImpl<$Res, _$SubjectStateLoadingImpl>
    implements _$$SubjectStateLoadingImplCopyWith<$Res> {
  __$$SubjectStateLoadingImplCopyWithImpl(_$SubjectStateLoadingImpl _value,
      $Res Function(_$SubjectStateLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubjectState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SubjectStateLoadingImpl implements SubjectStateLoading {
  const _$SubjectStateLoadingImpl();

  @override
  String toString() {
    return 'SubjectState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubjectStateLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<SubjectModel> subjects) loaded,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function() endedSession,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<SubjectModel> subjects)? loaded,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function()? endedSession,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<SubjectModel> subjects)? loaded,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function()? endedSession,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubjectStateLoaded value) loaded,
    required TResult Function(SubjectStateLoading value) loading,
    required TResult Function(SubjectStateError value) error,
    required TResult Function(SubjectStateEndedSession value) endedSession,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubjectStateLoaded value)? loaded,
    TResult? Function(SubjectStateLoading value)? loading,
    TResult? Function(SubjectStateError value)? error,
    TResult? Function(SubjectStateEndedSession value)? endedSession,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubjectStateLoaded value)? loaded,
    TResult Function(SubjectStateLoading value)? loading,
    TResult Function(SubjectStateError value)? error,
    TResult Function(SubjectStateEndedSession value)? endedSession,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class SubjectStateLoading implements SubjectState {
  const factory SubjectStateLoading() = _$SubjectStateLoadingImpl;
}

/// @nodoc
abstract class _$$SubjectStateErrorImplCopyWith<$Res> {
  factory _$$SubjectStateErrorImplCopyWith(_$SubjectStateErrorImpl value,
          $Res Function(_$SubjectStateErrorImpl) then) =
      __$$SubjectStateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$SubjectStateErrorImplCopyWithImpl<$Res>
    extends _$SubjectStateCopyWithImpl<$Res, _$SubjectStateErrorImpl>
    implements _$$SubjectStateErrorImplCopyWith<$Res> {
  __$$SubjectStateErrorImplCopyWithImpl(_$SubjectStateErrorImpl _value,
      $Res Function(_$SubjectStateErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubjectState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$SubjectStateErrorImpl(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SubjectStateErrorImpl implements SubjectStateError {
  const _$SubjectStateErrorImpl({required this.error});

  @override
  final String error;

  @override
  String toString() {
    return 'SubjectState.error(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubjectStateErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  /// Create a copy of SubjectState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubjectStateErrorImplCopyWith<_$SubjectStateErrorImpl> get copyWith =>
      __$$SubjectStateErrorImplCopyWithImpl<_$SubjectStateErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<SubjectModel> subjects) loaded,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function() endedSession,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<SubjectModel> subjects)? loaded,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function()? endedSession,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<SubjectModel> subjects)? loaded,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function()? endedSession,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubjectStateLoaded value) loaded,
    required TResult Function(SubjectStateLoading value) loading,
    required TResult Function(SubjectStateError value) error,
    required TResult Function(SubjectStateEndedSession value) endedSession,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubjectStateLoaded value)? loaded,
    TResult? Function(SubjectStateLoading value)? loading,
    TResult? Function(SubjectStateError value)? error,
    TResult? Function(SubjectStateEndedSession value)? endedSession,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubjectStateLoaded value)? loaded,
    TResult Function(SubjectStateLoading value)? loading,
    TResult Function(SubjectStateError value)? error,
    TResult Function(SubjectStateEndedSession value)? endedSession,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class SubjectStateError implements SubjectState {
  const factory SubjectStateError({required final String error}) =
      _$SubjectStateErrorImpl;

  String get error;

  /// Create a copy of SubjectState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubjectStateErrorImplCopyWith<_$SubjectStateErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SubjectStateEndedSessionImplCopyWith<$Res> {
  factory _$$SubjectStateEndedSessionImplCopyWith(
          _$SubjectStateEndedSessionImpl value,
          $Res Function(_$SubjectStateEndedSessionImpl) then) =
      __$$SubjectStateEndedSessionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SubjectStateEndedSessionImplCopyWithImpl<$Res>
    extends _$SubjectStateCopyWithImpl<$Res, _$SubjectStateEndedSessionImpl>
    implements _$$SubjectStateEndedSessionImplCopyWith<$Res> {
  __$$SubjectStateEndedSessionImplCopyWithImpl(
      _$SubjectStateEndedSessionImpl _value,
      $Res Function(_$SubjectStateEndedSessionImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubjectState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SubjectStateEndedSessionImpl implements SubjectStateEndedSession {
  const _$SubjectStateEndedSessionImpl();

  @override
  String toString() {
    return 'SubjectState.endedSession()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubjectStateEndedSessionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<SubjectModel> subjects) loaded,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function() endedSession,
  }) {
    return endedSession();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<SubjectModel> subjects)? loaded,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function()? endedSession,
  }) {
    return endedSession?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<SubjectModel> subjects)? loaded,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function()? endedSession,
    required TResult orElse(),
  }) {
    if (endedSession != null) {
      return endedSession();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubjectStateLoaded value) loaded,
    required TResult Function(SubjectStateLoading value) loading,
    required TResult Function(SubjectStateError value) error,
    required TResult Function(SubjectStateEndedSession value) endedSession,
  }) {
    return endedSession(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SubjectStateLoaded value)? loaded,
    TResult? Function(SubjectStateLoading value)? loading,
    TResult? Function(SubjectStateError value)? error,
    TResult? Function(SubjectStateEndedSession value)? endedSession,
  }) {
    return endedSession?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubjectStateLoaded value)? loaded,
    TResult Function(SubjectStateLoading value)? loading,
    TResult Function(SubjectStateError value)? error,
    TResult Function(SubjectStateEndedSession value)? endedSession,
    required TResult orElse(),
  }) {
    if (endedSession != null) {
      return endedSession(this);
    }
    return orElse();
  }
}

abstract class SubjectStateEndedSession implements SubjectState {
  const factory SubjectStateEndedSession() = _$SubjectStateEndedSessionImpl;
}
